from types import MappingProxyType; import sys; sys.tracebacklimit = 0; global debug; debug = False
temp_objects = {"environment": {"weather": None, "sky": {"sun": None, "moon-closest": None, "moon-middle": None, "moon-farthest": None}, "land": {"continent": {"all": None, "pyrrhia": None, "pantala": None}, "mountain": {"all": None, "range": {"clawsOfTheClouds": None, "darkstalkersTeeth": None}, "single": {"jadeMountain": None, "agateMountain": None, "borderlandMountain": None}}, "kingdom": {"all": None, "iceKingdom": None, "nightKingdom": None, "kingdomOfSand": None, "skyKingdom": None, "mudKingdom": None, "rainforestKingdom": None}, "jungle": {"poisonJungle": None}, "hive": {"tseteHive": None, "yellowjacketHive": None, "waspHive": None, "vinegaroonHive": None, "jewelHive": None, "hornetHive": None, "cicadaHive": None, "bloodwormHive": None, "mantisHive": None}}, "water": {"kingdom": {"kingdomOfTheSea": None}, "lakes": {"lakeScorpion": None}}}, "creature": {"animal": {"all": None, "sloth": None, "unknown": None}, "dragon": {"all": None, "icewing": None, "sandwing": None, "skywing": None, "mudwing": None, "rainwing": None, "nightwing": None, "seawing": None, "hivewing": None, "silkwing": None, "leafwing": None, "beetlewing": None}, "scavenger": {"all": None}}}; objects = MappingProxyType(temp_objects); del temp_objects
class world_object:
    def __init__(self, livestat=None, *rest): self.livestat, self.isEnchanted, self.objectName = livestat, False, f"{livestat}"; [(setattr(self, 'objectName', f"{self.objectName}.{x}")) for x in rest if x is not None]; print(f"Created object: {self.objectName}") if debug else None; (uhoh := livestat, level := objects.get(livestat), path := [livestat]); [(uhoh := ".".join(path), level := level[n] if level and n in level else exec('raise Exception(f"Unknown subtype: \'{n}\' for object: \'{uhoh}\'")'), path.append(n)) for n in rest if n is not None] if livestat in objects else exec('raise Exception(f"Unknown object type: \'{livestat}\'")'); current = objects[livestat]; [(current := current[key], print(f"Warning! \"{key}\" has no further specifiers. This will select a subtype at random!") if (m + 1 == len(rest) or rest[m+1] is None) and isinstance(current, (dict, list)) else None) for m, key in enumerate(rest) if key is not None]
    def getData(self, autoprint=False): tup = tuple(self.objectName.split(".")); (print(tup) if autoprint or debug else None); return tup
    def enchant(self, autoprint=False): self.isEnchanted = True; (print(f"Object {self.objectName} has been enchanted.") if debug or autoprint else None); return True
    def disenchant(self, autoprint=False): self.isEnchanted = False; (print(f"Object {self.objectName} has been disenchanted.") if debug or autoprint else None); return False
    def command(self, cmd, autoprint=False): res = f"Object {self.objectName} executed command: {cmd}" if self.isEnchanted else f"Error: Object {self.objectName} is not enchanted."; (print(res) if autoprint or debug else None); return res
def multicommand(*args, cmd, autoprint=False): se = [ar.objectName for ar in args if isinstance(ar, world_object) and ar.isEnchanted]; [(print(f"Object {ar.objectName} {'added' if ar.isEnchanted else 'is not enchanted and was ignored'}") if autoprint or debug else None) for ar in args if isinstance(ar, world_object)]; [(print(f"Non-indexed object ignored: {ar}") if not isinstance(ar, world_object) else None) for ar in args]; (print(f"Selected objects ({se}) executed command: {cmd}") if autoprint or debug else None); return se
